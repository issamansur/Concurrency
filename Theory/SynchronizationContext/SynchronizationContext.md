# Контекст синхронизации

Независимо от платформы — будь то `ASP.NET`, `Windows Forms`,
`Windows Presentation Foundation (WPF)`, `Silverlight` или нечто другое
— все `.NET`-программы включают концепцию `SynchronizationContext`,
и все программисты многопоточных приложений могут получить выигрыш
от его изучения и применения.

## Предыстория

### Необходимость  в синхронизации

Многопоточные программы существовали задолго до появления 
`.NET Framework`. Эти программы зачастую требовали, чтобы один поток
передавал какую-то единицу работы другому потоку. `Windows`-программы
были ориентированы на циклы обработки сообщений, поэтому многие
программисты использовали эту встроенную очередь для передачи единиц
работы. В каждой многопоточной программе, где нужно было использовать
очередь `Windows`-сообщений в такой манере, вы должны были определять
собственное `Windows`-сообщение и соглашение по его обработке.

Когда выпустили первую версию `.NET Framework`, этот распространенный
шаблон был стандартизован. В то время `.NET Framework` поддерживала
единственный тип `GUI` — `Windows Forms`. Однако проектировщики
этой инфраструктуры предвидели появление других моделей и разработали
обобщенное решение. Так родился `ISynchronizeInvoke`.

### ISynchronizeInvoke

Идея `ISynchronizeInvoke` в том, что поток-«источник» может поставить
делегат в очередь к потоку-«приемнику» и, как необязательный вариант,
ожидать завершения этого делегата. В `ISynchronizeInvoke` также было
свойство, которое позволяло определять, выполняется ли уже текущий код
в потоке-«приемнике»; в этом случае ставить делегат в очередь было бы
излишне. `Windows Forms` предоставляла единственную реализацию
`ISynchronizeInvoke`, а шаблон был предназначен для разработки
асинхронных компонентов, поэтому все были на седьмом небе от счастья.

В `.NET Framework 2.0` появилось много существенных изменений. Одно
из крупных усовершенствований заключалось во введении поддержки
асинхронных страниц в архитектуру `ASP.NET`. До `.NET Framework 2.0`
каждый `ASP.NET`-запрос требовал выполнения в своем потоке. Это было
неэффективной тратой потоков, так как создание веб-страницы часто
зависело от запросов к базе данных и вызовов веб-сервисов, а поток,
обрабатывающий запрос, был вынужден ждать завершения каждой из этих
операций. Благодаря поддержке асинхронных страниц поток, обрабатывающий
запрос, мог запускать каждую из операций, а затем возвращаться в пул
потоков `ASP.NET`; по окончании всех операций из пула `ASP.NET`
выделялся другой поток, который завершал обработку запроса.

Однако `ISynchronizeInvoke` не слишком хорошо подходил для архитектуры
`ASP.NET` с поддержкой асинхронных страниц. Асинхронные компоненты,
разработанные с использованием шаблона `ISynchronizeInvoke`, не смогли
бы корректно работать в страницах ASP.NET из-за того, что асинхронные
`ASP.NET`-страницы не сопоставлены с единственным потоком. Вместо
размещения работы в очереди к исходному потоку поддержке асинхронных
страниц нужно было лишь управлять счетчиком незавершенных операций,
чтобы определить, когда можно закончить обработку запроса страницы.
После долгих размышлений и тщательного продумывания проекта
`ISynchronizeInvoke` заменили на `SynchronizationContext`.

### Вывод:

Проще говоря (от меня):
в `ASP.NET` появились асинхронные операции, то есть мы можем не
блокировать и отпускать потоки обратно. После завершения асинхронных
операций мы можем вернуться в ЛЮБОЙ свободный поток.

НО! В `ASP.NET` нет постоянного «`UI-потока`», к которому можно
передавать работу — как это делается в `Windows Forms`. А
`ISynchronizeInvoke` предполагал, что есть один конкретный поток,
которому всё передаётся. Поэтому он не подходил для `ASP.NET` и подобных
сценариев.

## SynchronizationContext

### Отличия SynchronizationContext от ISynchronizeInvoke

`ISynchronizeInvoke` решал две задачи:
- определял, нужна ли синхронизация;
- ставил в очередь единицы работы от одного потока к другому;

`SynchronizationContext` изначально задумывался как замена
`ISynchronizeInvoke`, но в процессе создания превратился в нечто большее.

- Один из аспектов `SynchronizationContext` заключается в том, что он
предоставляет **способ размещения** единицы работы в очереди контекста.
```
Обратите внимание: не в очередь конкретного потока, а в очередь контекста.
Это важное отличие, так как многие реализации SynchronizationContext
основаны отнюдь не на единственном, конкретном потоке. В SynchronizationContext
нет механизма, определяющего, нужна ли синхронизация, поскольку определить
это не всегда возможно.
```
- Другой аспект `SynchronizationContext` — у каждого потока есть 
**«текущий»** контекст. Контекст потока не обязательно уникален;
экземпляр его контекста может использоваться совместно с другими потоками.
Поток может менять свой текущий контекст, но делается это крайне редко.
- Третий аспект `SynchronizationContext` — **хранение счетчика**
незавершенных асинхронных операций. Это позволяет использовать
асинхронные `ASP.NET`-страницы и любой другой хост, где нужен счетчик
такого рода. В большинстве случаев значение счетчика увеличивается на 1,
когда захватывается текущий `SynchronizationContext`, и уменьшается на 1,
когда захваченный `SynchronizationContext` используется для размещения
уведомления о завершении в очереди контекста.

Другие аспекты `SynchronizationContext`:

```csharp
// The important aspects of the SynchronizationContext APIclass SynchronizationContext

{

  // Dispatch work to the context.

  void Post(..); // (asynchronously)

  void Send(..); // (synchronously)

  // Keep track of the number of asynchronous operations.

  void OperationStarted();

  void OperationCompleted();

  // Each thread has a current context.

  // If "Current" is null, then the thread's current context is


  // "new SynchronizationContext()", by convention.

  static SynchronizationContext Current { get; }

  static void SetSynchronizationContext(SynchronizationContext);
}
```

### Реализации SynchronizationContext

Четкого определения истинного «контекста» `SynchronizationContext` нет.
В разных инфраструктурах и хостах могут быть определены свои контексты:

- `WindowsFormsSynchronizationContext` (`System.Windows.Forms.dll`: `System.Windows.Forms`)
```
Приложения Windows Forms будут создавать и устанавливать
WindowsFormsSynchronizationContext в качестве текущего контекста для
любого потока, который создает UI-элементы. 

Этот SynchronizationContext использует методы ISynchronizeInvoke
применительно к UI-элементу, который передает делегаты нижележащему
Win32-циклу обработки сообщений.

Контекст для WindowsFormsSynchronizationContext — единственный UI-поток.

Все делегаты выполняются по одному в том порядке, 
в каком они были поставлены в очередь.

Текущая реализация создает один WindowsFormsSynchronizationContext 
для каждого UI-потока.
```

- `DispatcherSynchronizationContext` (`WindowsBase.dll`: `System.Windows.Threading`)
```
Приложения WPF и Silverlight используют DispatcherSynchronizationContext,
который ставит делегаты в очередь Dispatcher, принадлежащего UI-потоку.

Этот SynchronizationContext устанавливается как текущий контекст,
когда поток начинает свой цикл Dispatcher вызовом Dispatcher.Run. 

Контекст для DispatcherSynchronizationContext — единственный UI-поток.
 
Все делегаты выполняются по одному в том порядке, 
в каком они были поставлены в очередь.

Текущая реализация создает один DispatcherSynchronizationContext
для каждого окна верхнего уровня, даже если все они используют
один и тот же нижележащий Dispatcher.
```

- `SynchronizationContext` по умолчанию (`ThreadPool`) (`mscorlib.dll`: `System.Threading`)

```
Это объект SynchronizationContext, сконструированный по умолчанию.

По соглашению, если текущий SynchronizationContext потока равен null, 
тогда этому потоку неявно назначен SynchronizationContext по умолчанию.

SynchronizationContext по умолчанию помещает свои асинхронные делегаты
в очередь ThreadPool, а синхронные делегаты выполняет непосредственно
в вызвавшем потоке. Поэтому его контекст охватывает все потоки ThreadPool,
а также любой поток, который вызывает Send.

SynchronizationContext «заимствует» потоки, вызвавшие Send, и переводит
их в свой контекст до завершения делегата. В этом смысле контекст
по умолчанию может включать любой поток в процессе.
 
SynchronizationContext по умолчанию применяется к потокам ThreadPool,
если только код на размещен в ASP.NET. SynchronizationContext по
умолчанию также неявно применяется к явным образом созданным дочерним
потокам (экземплярам класса Thread), если только дочерний поток не
устанавливает собственный контекст.

Таким образом, в UI-приложениях обычно имеется два контекста
синхронизации: UI SynchronizationContext, охватывающий UI-поток,
и SynchronizationContext по умолчанию, охватывающий потоки ThreadPool.
```

Примечание от меня:

Не стоит путать, что `ThreadPool` - реализация `SynchronizationContext`!
Делегаты от `continuous` выполняются в `ThreadPool.QueueUserWorkItem`
(под капотом разумеется оборачивается в таску, чтобы не было Unhandled
Exception).

Таким образом, `ThreadPool` инструмент для выполнения делегатов с 
нужной настройкой, т.е. без явного привязанного контекста. В отличие
от того, когда контекст есть и вызываются методы такие как
`SynchronizationContext.Send` и `SynchronizationContext.Post`.

