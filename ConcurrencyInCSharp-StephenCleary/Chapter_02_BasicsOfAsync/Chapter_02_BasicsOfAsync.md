## Экспоненциальная задержка

**Экспоненциальная задержка** — стратегия 
увеличения задержек между повторными попытками.
Используйте ее при работе с веб-службами, чтобы
не перегружать сервер повторными попытками.

```
В реальном коде я бы рекомендовал применить более 
качественное решение (например, использующее 
библиотеку Polly NuGet).
```

## Приостановка на заданный период времени

`Task.Delay` неплохо подходит для модульного тестирования 
асинхронного кода или реализации логики повторных попыток.
Но если нужно реализовать тайм-аут, лучшим кандидатом
будет `CancellationToken`.

## Возврат результатов синхронных методов с асинхронной сигнатурой

Можно использовать `Task.FromResult` для создания и возвращения
нового объекта `Task<T>`, уже завершенного с заданным значением.

Для методов, не имеющих возвращаемого значения, можно 
использовать `Task.CompletedTask` — кэшированный объект
успешно завершенной задачи `Task`.

Если потребуется задача с результатом ошибки вы можете
использовать `Task.FromException`.

Аналогично существует метод `Task.FromCanceled` для создания
задач, уже отмененных из заданного маркера
`CancellationToken`.

Если вы регулярно используете `Task.FromResult` с одним 
значением, подумайте о кэшировании задачи.

```
На логическом уровне Task.FromResult, Task.FromException и Task.
 FromCanceled  являются вспомогательными методами и сокращенными
формами обобщенного типа TaskCompletionSource<T>. 
TaskCompletionSource<T> представляет собой низкоуровневый тип,
полезный для взаимодействия с другими формами асинхронного кода.
```

```
В общем случае следует применять сокращенную форму 
Task.FromResult и родственные формы, если хотите вернуть уже 
завершенную задачу. Используйте TaskCompletionSource<T> 
для возвращения задачи, которая завершается в некоторый момент
будущего.
```

## Передача информации о ходе выполнения операции (IProgress<T>)

Используйте типы `IProgress<T>` и `Progress<T>`. 
Ваш `async`-метод должен получать аргумент `IProgress<T>`;
здесь `T` — тип прогресса, о котором вы хотите сообщать.

Помните, что метод `IProgress<T>.Report` обычно является 
асинхронным. Это означает, что `MyMethodAsync` может продолжить
выполнение перед сообщением о прогрессе.

По этой причине лучше определить `T` как неизменяемый тип 
(или по крайней мере тип-значение). Если T является изменяемым
ссылочным типом, то вам придется самостоятельно создавать
отдельную копию при каждом вызове `IProgress<T>.Report`.

`Progress<T>` сохраняет текущий контекст при создании и 
активизирует свой обратный вызов в этом контексте. Это 
означает, что если `Progress<T>` конструируется в UI-потоке,
то вы сможете обновить пользовательский интерфейс из его
обратного вызова, даже если асинхронный метод вызывает 
`Report` из фонового потока.