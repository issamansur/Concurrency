## Асинхронность

`async`-метод может рассматриваться как состоящий из нескольких синхронных частей, 
разделенных командами await.

```
Внутри async-метода команда await выполняет асинхронное ожидание по 
своему аргументу. Сначала она проверяет, завершилась ли операция: если 
да, то метод продолжает выполняться (синхронно). В противном случае 
await приостанавливает async-метод и возвращает незавершенную задачу. 
Когда операция завершится позднее, метод async продолжает выполнение
```

При выполнении await для задачи (самый распространенный сценарий)
в момент, когда await решает приостановить метод, сохраняется контекст.
Это текущий объект `SynchronizationContext`, если только он не равен
`null` (в этом случае контекстом является текущий объект TaskScheduler).
Метод возобновляет выполнение в этом сохраненном контексте. Обычно
контекстом является UI-контекст (для UI-потока) или контекст пула
потоков (в большинстве других ситуаций). Если вы пишете приложение
ASP.NET Classic (до Core), то контекстом также может быть контекст
запроса ASP.NET.

```
В ASP.NET Core используется контекст пула потоков
вместо специального контекста запроса.
```

Относительно async-методов существует одна важная рекомендация:
при использовании ключевого слова async лучше позволить ему 
распространяться в вашем коде. 

```
Если вы вызываете async-метод, следует
(в конечном итоге) выполнить await для возвращаемой им задачи.
Боритесь с искушением вызвать Task.Wait, Task<TResult>.Result или
GetAwaiter().GetResult(): это приведет к взаимоблокировке (deadlock).
```

## Параллелизм

Есть две формы параллельного программирования: параллелизм данных
и параллелизм задач.

```
Параллелизм данных возникает тогда, когда имеется 
набор элементов данных, ожидающих обработки, и обработка каждого 
фрагмента данных в основном не зависит от других фрагментов.

Под параллелизмом задач понимается такая ситуация, в которой 
имеется некоторый пул работы, где каждый фрагмент работы в 
основном не зависит от остальных.

Параллелизм задач может быть динамическим — если один 
фрагмент работы порождает несколько дополнительных фрагментов 
работы, они могут быть добавлены в пул работы.
```

Блоки работы

```
Блоки работы должны быть независимы друг от друга настолько, 
насколько это возможно.
```

Результаты параллельной обработки могут обрабатываться разными способами. 

```
Выход можно поместить в некоторую разновидность конкурентной 
коллекции или же провести агрегирование результатов для получения 
сводного показателя. Агрегирование часто применяется в параллельной 
обработке; такая разновидность функциональности «отображение/свертка»
также поддерживается перегруженными версиями методов класса Parallel.
```

Обработка ошибок при всех типах параллелизма 

```
Так как операции выполняются параллельно, в программе могут
возникнуть множественные исключения, поэтому они упаковываются
в исключение AggregateException, запускаемое в ваш код.
```

Задачи при параллельной работе должны быть ни слишком короткими, ни слишком длинными.

```
Если задачи получаются слишком короткими, то затраты ресурсов на 
разбиение данных на задачи и планирование этих задач в пуле потоков 
начинают играть значительную роль. Если задачи слишком длинные, то 
пул потоков не может динамически регулировать равномерное распределение
работы. Трудно заранее определить, какую задачу следует считать 
«слишком короткой» или «слишком длинной»; это зависит от решаемой 
задачи и приблизительных возможностей оборудования.
```

## Реактивность

Ранее пакет `System.Reactive` назывался `Reactive Extensions`; это 
название часто сокращалось до «Rx.» Все три термина относятся 
к одной технологии.

Реактивное программирование основано на концепции наблюдаемых
потоков (observable streams).

```
Подписавшись на наблюдаемый поток, вы будете получать любое 
количество элементов данных (OnNext); потокможет завершиться 
одной ошибкой (OnError) или уведомлением «конецпотока» (OnCompleted). 
Некоторые наблюдаемые потоки никогда не завершаются.
```

Главное отличие заключается в том, что LINQ to Objects и LINQ to Entities
используют модель вытягивания (pull model), при которой перечисление 
запроса LINQ «вытягивает» данные из запроса, тогда как LINQ to Events 
(System.Reactive) использует модель проталкивания (push model),
при которой события поступают и перемещаются по запросу сами по себе.

Подписки ведут себя по-разному с холодными и горячими наблюдаемыми
объектами. Горячий (hot) наблюдаемый объект представляет собой поток
событий, который всегда находится в движении, и, если при появлении
события нет ни одного подписчика, оно теряется. Например, перемещение
мыши является горячим наблюдаемым событием. У холодного (cold)
наблюдаемого объекта события не поступают постоянно. 

```
Холодный наблюдаемый объект реагирует на подписку, начиная 
последовательность  событий. Например, загрузка HTTP является холодным 
наблюдаемым объектом; подписка инициирует отправку запроса HTTP.
```

```
Оператор Subscribe также всегда должен получать параметр обработки 
ошибок.
```