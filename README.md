### Основные понятия

**Конкурентность** <br>
Выполнение сразу нескольких действий в одно и то же время.

- **Многопоточность**  

    Форма конкурентности, использующая несколько 
    программных *потоков* выполнения.

- - **Параллельная обработка**

    Выполнение большого объема работы за счет распределения ее
    между несколькими *потоками* / *ядрами*, выполняемыми одновременно.


- **Асинхронное программирование**

  Разновидность конкурентности, использующая *обещания* или
  *обратные вызовы* для предотвращения создания лишних потоков.

```
Обещание (future/promise), или преднамеченный тип — тип, представляющий 
некоторую операцию, которая завершится в будущем. Примеры современных 
типов обещаний в .NET — Task и Task<TResult>.
```

- **Реактивное программирование**

  *Декларативный* стиль программирования, при котором приложение
  реагирует на *события*.

### Важные моменты

- Двойное назначение `async`

1. Разрешает использование ключевого слова `await` внутри этого метода
2. Говорит компилятору сгенерировать для этого метода конечный автомат по аналогии 
с тем, как работает `yield return`.

- Не используйте `async void`

Избегайте async `void`! Возможно создать `async`-метод, который возвращает 
`void`, но это следует делать только при написании `async` обработчика событий.
Обычный async-метод без возвращаемого значения должен возвращать `Task`, а не `void`.

- `ConfigureAwait(false)` и возобновление контекста

Хорошей практикой программирования считается вызывать `ConfigureAwait(false)` 
в базовых «библиотечных» методах и возобновлять контекст только тогда, 
когда потребуется — в ваших внешних методах «пользовательского интерфейса».

- Использование `async`

Используйте `async` по полной программе.

- Рекомендация для параллельной обработки

Блоки работы должны быть независимы друг от друга настолько,
насколько это возможно

- Размеры задач

Задачи должны быть ни слишком короткими, ни слишком длинными.

```
Если задачи получаются слишком короткими, то затраты ресурсов на 
разбиение данных на задачи и планирование этих задач в пуле потоков 
начинают играть значительную роль. Если задачи слишком длинные, то 
пул потоков не может динамически регулировать равномерное 
распределение работы. Трудно заранее определить, какую задачу следует 
считать «слишком короткой» или «слишком длинной»; это зависит от 
решаемой задачи и приблизительных возможностей оборудования.
```

- Реактивность

Ранее пакет `System.Reactive` назывался `Reactive Extensions`; это
название часто сокращалось до «Rx.» Все три термина относятся
к одной технологии.

- Экспоненциальная задержка
  
В реальном коде я бы рекомендовал применить более 
качественное решение (например, использующее 
библиотеку `Polly NuGet`)

- Обработка каждой задачи после ее завершения

Метод расширения `OrderByCompletion` также доступен в 
библиотеке с открытым кодом `AsyncEx` 
(NuGet-пакет `Nito.AsyncEx`).

- Собственный `SynchronizationContext`

Если нужно предоставить ваш собственный тип 
`SynchronizationContext` - (например, `AsyncContext`)

Тип `AsyncContext` находится в пакете `Nito.AsyncEx`.

- Ожидание `ValueTask`

`ValueTask` или `ValueTask<T>` может ожидаться только один
раз, поэтому вы не можете одновременно использовать `await`
и вызвать `AsTask` для одного `ValueTask<T>`.

Синхронное получение результатов от `ValueTask` или 
`ValueTask<T>` может быть выполнено только один раз, после 
завершения `ValueTask`, и это значение` ValueTask` уже не 
может использоваться для ожидания или преобразования в 
задачу.