# Контекст исполнения

С каждым потоком связан определенный **контекст исполнения**.
Он включает в себя:

1) параметры безопасности (сжатый стек, свойство Principal объекта
   `Thread` и идентификационные данные Windows)
2) параметры хоста (`System.Threading.HostExecutionContextManager`) и
   контекстные данные логического вызова (см. методы `LogicalSetData` и
   `LogicalGetData` класса `System.Runtime.Remoting.Messaging.CallContext`).

Когда поток исполняет код, значения **_параметров контекста исполнения_**
оказывают влияние на некоторые операции. В идеале всякий раз при использовании
для выполнения заданий вспомогательного потока в этот вспомогательный поток
должен копироваться контекст исполнения первого потока. Это гарантирует
использование одинаковых параметров безопасности и хоста в обоих потоках,
а также доступ вспомогательного потока к данным, сохраненным в контексте
логического вызова исходного потока.

По умолчанию CLR автоматически копирует контекст исполнения самого
первого потока во все вспомогательные потоки. Это гарантирует безопасность,
но в ущерб производительности, потому что в контексте исполнения содержится
много информации. Сбор всей информации и ее копирование во вспомогательные
потоки занимает немало времени. Вспомогательный поток может, в свою очередь,
использовать вспомогательные потоки, при этом создаются и инициализируются
дополнительные структуры данных.

Класс `ExecutionContext` в пространстве имен `System.Threading` позволяет
управлять копированием контекста исполнения потока.

```csharp
public sealed class ExecutionContext : IDisposable, ISerializable {
   [SecurityCritical]
   public static AsyncFlowControl SuppressFlow();
   public static void RestoreFlow();
   public static Boolean IsFlowSuppressed();
   // Не показаны редко применяемые методы
}
```

С помощью этого класса можно запретить копирование контекста исполнения,
повысив производительность приложения. Для серверных приложений рост
производительности в этом случае оказывается весьма значительным. 
Для клиентских приложений особой выгоды нет, кроме того, метод `SuppressFlow`
помечается атрибутом `[SecurityCritical]`, в результате становится невозможным
вызов некоторых клиентских приложений (например, `Microsoft Silverlight`).
Разумеется, запрещать копирование контекста исполнения можно, только если
вспомогательному потоку не требуется содержащаяся там информация. 
Когда инициирующий контекст исполнения не переходит во вспомогательный поток,
тот использует последний связанный с ним контекст исполнения. Поэтому при
отключенном копировании контекста поток не должен исполнять код, зависящий
от состояния текущего контекста исполнения (например, идентификационных
данных пользователя Windows).

Следующий пример демонстрирует, как запрет на копирование контекста
исполнения влияет на данные в контексте логического вызова потока при
постановке рабочего элемента в очередь в `CLR`-пуле:

!!! Внимание, тут используется устаревший `CallContext`, который использовался
до `.NET 5`. Сейчас используется `AsyncLocal` смотрите `ExecutionContextExample`.

```csharp
public static void Main() {
   // Помещаем данные в контекст логического вызова потока метода Main
   CallContext.LogicalSetData("Name", "Jeffrey");
   // Заставляем поток из пула работать
   // Поток из пула имеет доступ к данным контекста логического вызова
   ThreadPool.QueueUserWorkItem(
       state => Console.WriteLine(
           "Name={0}",
           CallContext.LogicalGetData("Name")
       )
   );
   
   // Запрещаем копирование контекста исполнения потока метода Main
   ExecutionContext.SuppressFlow();
   
   // Заставляем поток из пула выполнить работу.
   // Поток из пула НЕ имеет доступа к данным контекста логического вызова
   ThreadPool.QueueUserWorkItem(
       state => Console.WriteLine(
           "Name={0}", 
           CallContext.LogicalGetData("Name")
       )
   );
   // Восстанавливаем копирование контекста исполнения потока метода Main
   // на случай будущей работы с другими потоками из пула
   ExecutionContext.RestoreFlow();
   ...
   Console.ReadLine();
}
```

Пока мы обсуждаем только запрет копирования контекста исполнения при вызове
метода `ThreadPool.QueueUserWorkItem`, но этот прием используется как при
работе с объектами `Task` (см. раздел «Задания» данной главы), так и при
инициировании асинхронных операций ввода-вывода.